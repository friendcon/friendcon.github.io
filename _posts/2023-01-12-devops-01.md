---
title: "MSA 개론"
excerpt: "도메인 주도 설계로 시작하는 마이크로서비스 개발 😎"

categories:
  - Devops
tags:
  - [Devops]

permalink: /category/devops/1

toc: true
toc_sticky: true

date: 2023-01-12
last_modified_at: 2023-01-12
---
## 🦥 모놀리식 구조
- 하나의 단위로 개발되는 일체형 애플리케이션
- 3티어로 불리는 사용자 인터페이스, 데이터베이스, 서버 애플리케이션으로 구성
- 작은 변화에도 새로운 버전으로 전체를 빌드해서 배포해야함
- 특정 기능만 확장 불가
- 전체 애플리케이션을 동시에 확장해야 함

  <img src="https://imgur.com/ST9QZVp.png">
## 🦥 MSA 구조
- 서버측이 여러 개의 조각으로 구성됨
- 서비스 인스턴스가 모여 하나의 비즈니스 애플리케이션 구현
- 확장 시에는 특정 기능별로 독립적인 확장이 가능
- 서비스 변경시 해당 서비스만 빌드해서 배포
- 서비스가 독립적이어서 서로 다른 프레임워크, 언어로 개발 가능

  <img src="https://imgur.com/Ifqt7nG.png">

### 🌿 MSA 장점 정리
- 서비스별 저장소를 분리해서 다른 서비스가 저장소를 직접 호출하지 못하도록 캡슐화
- 다른 서비스의 저장소에 접근하는 방법은 API 밖에 없음

## 🦥 리액티브 선언
- 현대 애플리케이션이 갖춰야 할 바람직한 속성을 뜻한다
### 🌿 응답성
- 사용자에게 `신뢰성 있는 응답`을 빠르게 줘라

### 🌿 탄력성
- 장애가 발생하거나 부분적으로 고장이 나도 시스템 전체가 고장나지 않고 `빠르게 복구`하는 능력을 갖춰라

### 🌿 유연성
- 사용량에 변화가 있더라도 균일한 응답성을 제공
- 사용량에 비례하여 자원을 늘리거나 줄여라

### 🌿 메세지 기반
- 비동기 메세지 전달을 통해 위치 투명성, 느슨한 결합, 논블로킹 통신을 지향해라

## 🦥 API 게이트웨이 패턴
<img src="https://imgur.com/vlLbfNb.png">

- 레지스트리 서비스와 연계한 동적 라우팅 및 로드 밸런싱
- 인증 및 인가
- 로그 집계 서비스
- `Spring API Gateway Service` 로 구현 가능

## 🦥 MSA 에서 인증/인가 구현 방법
- 구매 서비스, 배송 서비스, 리뷰 서비스 모두 인증이 필요하다. 각 서비스마다 인증/인가를 중복으로 구현하는 것은 비효율적이기 때문에 MSA 에서는 다음과 같은 패턴을 활용한다.

### 🌿 중앙 집중식 세션 관리
- 공유 저장소에 세션을 저장하고 모든 서비스가 동일한 사용자를 얻을 수 있도록 한다.
- 보통 Redis, Memcached 를 사용

### 🌿 클라이언트 토큰
- 서버에서 클라이언트에게 토큰을 발급하고 클라이언트 측에 토큰을 저장한다.
- 클라이언트는 토큰을 가지고 요청을 한다
- JWT 를 많이 사용한다

  <img src="https://imgur.com/Qvythww.png">

## 🦥 MSA 통신 패턴
### 🌿 동기 통신 방식
- 동기 방식은 요청을 하면 바로 응답을 하는 방식이다
- 요청을 보낸 서비스는 반응이 올 때까지 기다리고 반응이 안온다면 재호출을 한다

  <img src="https://imgur.com/wL22Jek.png">

### 🌿 비동기 통신 방식
- 동기 방식처럼 요청을 보내고 응답을 기다리지 않는다.
- 메세지를 보낸 다음 응답을 기다리지 않고 다음 일을 처리한다.
- 결과에 대한 응답을 받지 못하므로 완결성을 보장할 순 없음
- 완결성을 보장하기 위한 메커니즘이 `카프카(Apache Kafka)` , `래빗엠큐(RabbitMQ)`, `액티브엠큐(ActiveMQ)` 같은 메세지 브로커이다.

  <img src="https://imgur.com/2mNPB6U.png">

#### 💡 생산자와 소비자
- 메세지를 보내는 생산자, 메세지를 가져가서 처리하는 소비자가 직접 접속하지 않고 메세지 브로커에 연결
- 메세지를 보내고 본인의 업무를 하면 메세지 브로커가 알아서 전송처리를 해준다

  <img src="https://imgur.com/t4bv0vc.png">

  - 동기 방식일 때
  
    - 손님이 커피 주문 -> 주문 접수 -> 주문 담당자가 제조 요청 -> 주문 접수 직원은 제조가 될 때까지 기다림 -> 커피 제작 완료 -> 손님은 커피 수령
    - 위의 방식으로 카페가 운영된다면.. 매우 비효율적이다. 제조될 때 까지 기다리는 시간에 다른 손님의 주문을 받는다면 효율적인 카페 운영이 가능하다.

  - 비동기 방식일 때

    - 손님이 커피 주문 -> 주문 접수 -> 제조 요청 -> 다음 손님이 없을 때 까지 주문 접수 -> ... -> 제조 담당자는 커피 제작 완료 -> 손님은 커피 수령
    - 이벤트를 생산하는 모듈 이벤트(커피 주문)에 대응하는 모듈(주문을 통한 제작) 분리 후 독립적으로 
    - `상태 변경에 대한 반응으로 동작`