---
title: "[JAVA] 클래스와 상속"
excerpt: "기본기를 쌓기위한 JAVA 공부"

categories:
  - Java
tags:
  - [Java]

permalink: /category/java/3

toc: true
toc_sticky: true

date: 2023-01-19
last_modified_at: 2023-01-19
---
## 🦥 객체 지향 프로그래밍
- 현실 세계의 문제들을 소프트웨어 객체로 추상화하고 객체의 메서드를 통해 메세지를 주고받으면서 프로그램의 기능을 완성시키는 것을 객체 지향 프로그래밍이라고 한다. 

### 🌿 객체
- 기능을 추상화한 것으로 속성과 동작을 가지고 있고 다른 것과 식별 가능한 것을 객체라고 한다.
- 자바에서 속성과 동작을 필드와 메서드라고 부른다.

### 🌿 클래스
- 객체를 생성하기 위해 필드와 메서드가 정의되어 있는 것
- 객체는 클래스의 인스턴스고 객체를 만드는 과정을 인스턴스화 라고 한다.

## 🦥 객체 지향의 특싱
### 🌿 캡슐화
- 객체의 필드, 메서드를 하나로 묶어 실제 구현 내용을 감추는 것
- 외부 객체는 객체의 내부 구조를 알 수 없음
- 객체의 보호를 위해 사용
- 접근제한자를 사용하여 객체 필드와 메서드의 사용 범위를 제한하여 보호할 수 있음.

### 🌿 상속
- 상위 객체의 필드와 메서드를 하위 객체에게 물려주어 하위 객체가 사용할 수 있도록 하는 것 
- 객체의 재사용으로 반복된 코드를 줄여준다

### 🌿 다형성
- 같은 타입이지만 실행 결과가 다양한 성질

## 🦥 클래스의 구성 요소
### 🌿 필드
- 객체의 고유 데이터, 상태 정보를 저장하는 곳

### 🌿 생성자
- 객체 생성 시 초기화 담당
- 필드 초기화 혹은 메서드 호출

#### 💡 기본 생성자
- 선언하지 않아도 자동으로 생성되는 생성자 (단 생성자가 아무것도 없을 경우)
- 필드 초기값을 설정하고 싶을 경우 사용
#### 💡 일반 생성자 선언 방법
```
클래스(매개변수~) {
  // 객체 초기화
}
```
- 일반 생성자를 선언되어 있다면 기본 생성자를 자동으로 추가하지 않음
#### 💡 생성자 오버로딩
- 매개변수의 타입과 수가 다른 생성자를 여러개 선언하는 것

- 예시
  ```
  public class Bazzi {
    Bazzi(){ }
    Bazzi(String name, Color color){ }
    Bazzi(String name, Color color, Acc acc) { }
  }
  ```

### 🌿 메서드
- 필드를 읽고 쓰는 역할, 객체 간 데이터를 전달하는 역할

#### 💡 메서드 오버로딩
- 클래스 내에 같은 이름의 메서드를 여러개 선언
- 매개변수 개수, 타입, 순서가 달라야 한다

## 🦥 this
- 객체 내부에서 인스턴스 멤버, 생성자에 접근하기 위해 사용

## 🦥 static
- 객체를 생성하지 않고 사용할 수 있는 필드와 메서드
- 인스턴스에 소속된 멤버가 아닌 클래스에 소속된 멤버
- 클래스 로더가 클래스를 로딩하고 메서드 영역에 적재하면 바로 사용가능
### 🌿 정적 멤버 메서드 선언
```
class Bazzi {
  static 타입 필드;
  static 리턴타입 메서드이름(매개변수) { }
}
```
### 🌿 정적 초기화 블록
- 정적 블록을 사용하여 정적 필드의 복잡한 초기화 작업을 한다
- 클래스가 메모리에 로딩될 때 정적 블록 실행
- 정적 메서드와 정적 블록에서 인스턴스 멤버를 사용하고 싶은 경우 객체를 생성하고 참조 변수로 접근
```
class Bazzi {
  static String name = "Bazzi"
  static String type = "Angel"
  static String nickname;

  static {
    nickname = name + type;
  }
}
```
## 🦥 싱글톤
- 단 하나의 객체만 만들 수 있는 패턴
- 외부에서 new 할 수 없도록 해야한다
- 생성자 앞에 private 접근 제한자를 붙이면 싱글톤 패턴을 만들 수 있다

```
public class Bazzi {
  private static Bazzi singleton = new Bazzi();

  private Bazzi() {

  }

  static Bazzi getInstance() {
    return singleton;
  }
}
```

## 🦥 final 과 상수
### 🌿 final
- final 필드는 초기값이 저장되면 최종값이 되어 프로그램 실행 도중 수정할 수 없는 값
- 선언방법은 생성자에서 주는 방법, 필드 선언에서 선언하는 방법 두가지가 있다

```
public class Sample {
  final String name = "BAZZI";
  final String nickname;

  public Sample(String nickname) {
    this.nickname = nickname;
  }
}
```
### 🌿 상수
- 불변의 값
- 불변의 값은 객체마다 저장할 필요가 없는 공용값
```
static final 타입 상수;
static {
  상수 = 초기값;
}
```
## 🦥 접근 제한자
|접근 제한자|적용 대상|접근할 수 없는 클래스|
|:---:|:---:|:---:|
|public|클래스, 필드, 생성자, 메서드|없음|
|protected|필드, 생성자, 메서드|자식 클래스가 아닌 다른 패키지에 소속된 클래스(다른패키지의 자식 클래스라면 생성자 호출 가능)|
|default|클래스, 필드, 생성자, 메서드|다른 패키지에 소속된 클래스|
|private|필드, 생성자, 메서드|모든 외부 클래스|

## 🦥 어노테이션
- 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
- 실행시 특정 기능을 실행하도록 정보 제공
- 코드를 자동으로 생성할 수 있도록 정보 제공

## 🦥 상속
- 부모 클래스의 필드와 메서드를 자식 클래스에게 물려주는 것
- 코드의 중복을 줄여준다
- extends 뒤에는 하나의 부모클래스만 올 수 있다
```
class 부모클래스 {
  ...
}
class 자식클래스 extends 부모클래스 {
  ...
}
```

### 🌿 부모 생성자 
- 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성

## 🦥 final 클래스
- 최종 클래스로 상속할 수 없는 클래스

## 🦥 final 메서드
- 오버라이딩 할 수 없는 메서드

## 🦥 타입 변환
### 🌿 자동 타입 변환
- 프로그램 실행 도중에 자동으로 타입 변환이 일어나는 것
- 부모 타입 변수에 자식 타입이 할당되는 것
- 바로 위의 부모가 아니더라도 상위 타입이라면 자동 타입 변환이 일어날 수 있다
- 부모 클래스에 선언된 필드와 메서드에만 접근 가능하다
- 자식 클래스에서 메서드가 오버라이딩 되었을 경우 자식 클래스 메서드가 호출

### 🌿 강제 타입 변환
- 부모 타입을 자식 타입으로 변환하는 것
- 자식 타입이 부모 타입으로 변환 후 자식 타입으로 변환할 때 강제 타입 변환 사용

## 🦥 추상 클래스
- 클래스들의 공통적인 특성을 추출해서 선언한 클래스를 추상 클래스라고 한다
- 추상 클래스는 new 를 사용해서 인스턴스를 생성하지 못한다
- 실체 클래스의 메서드 이름, 공통 필드 이름을 통일시키기 위해
- 실체 클래스 작성 시간 절약

```
public abstract class 클래스 {
  // 필드
  // 생성자
  // 메서드
}
```
## 🦥 추상 메서드
- 메서드 선언만 통일하고 실행 내용은 클래스마다 달라야 하는 경우
- 추상 메서드는 추상 클래스에서만 선언 가능
```
abstract 리턴타입 메서드명(매개변수);
```